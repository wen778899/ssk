// 智能十三水AI分牌 - 同花顺绝对做尾道增强版
// 1. 特殊牌型优先 2. 若有同花顺必做尾道 3. 全局最优候选法 4. 不倒水兜底

const TAIL_TOP_N = 14;   // 尾道候选数量
const MID_TOP_N = 12;    // 中道候选数量;

function getRank(card) {
  const v = card.split('_')[0];
  if (v === 'ace') return 14;
  if (v === 'king') return 13;
  if (v === 'queen') return 12;
  if (v === 'jack') return 11;
  return parseInt(v, 10);
}

function cardValue(card) {
  const v = card.split('_')[0];
  if (v === \'ace\') return 14;
  if (v === \'king\') return 13;
  if (v === \'queen\') return 12;
  if (v === \'jack\') return 11;
  return parseInt(v, 10);
}
function cardSuit(card) {
  return card.split(\'_\')[2];
}
function uniq(arr) { return [...new Set(arr)]; }
function groupBy(arr, fn = x => x) {\n  const g = {};\n  arr.forEach(x => {\n    const k = fn(x); g[k] = g[k] || []; g[k].push(x);\n  });\n  return g;\n}
function getTotalValue(cards) {
  return cards.reduce((sum, c) => sum + cardValue(c), 0);
}
function combinations(arr, k) {\n  let res = [];\n  function comb(path, start) {\n    if (path.length === k) return res.push(path);\n    for (let i = start; i < arr.length; ++i) comb([...path, arr[i]], i + 1);\n  }\n  comb([], 0);\n  return res;\n}
function sortCards(cards) {\n  return [...cards].sort((a, b) => cardValue(b) - cardValue(a) || cardSuit(b).localeCompare(cardSuit(a)));\n}

// ==== 特殊牌型检测 ====\nfunction detectDragon(cards13) {\n  const vals = uniq(cards13.map(cardValue));\n  if (vals.length === 13) {\n    const sorted = sortCards(cards13);\n    return { head: sorted.slice(0, 3), middle: sorted.slice(3, 8), tail: sorted.slice(8, 13), type: \'一条龙\' };\n  }\n  return null;\n}\nfunction detectSixPairs(cards13) {\n  const byVal = groupBy(cards13, cardValue);\n  const pairs = Object.values(byVal).filter(g => g.length === 2);\n  if (pairs.length === 6) {\n    let head = pairs[0].concat(pairs[1][0]);\n    let used = new Set(head);\n    let mid = pairs[1].slice(1).concat(pairs[2], pairs[3][0]);\n    used = new Set([...head, ...mid]);\n    let tail = cards13.filter(c => !used.has(c));\n    if (head.length === 3 && mid.length === 5 && tail.length === 5)\n      return { head, middle: mid, tail, type: \'六对半\' };\n  }\n  return null;\n}\nfunction detectThreeStraight(cards13) {\n  const comb3 = combinations(cards13, 3);\n  for (const head of comb3) {\n    if (!isStraight(head)) continue;\n    const left10 = cards13.filter(c => !head.includes(c));\n    for (const mid of combinations(left10, 5)) {\n      if (!isStraight(mid)) continue;\n      const tail = left10.filter(c => !mid.includes(c));\n      if (!isStraight(tail)) continue;\n      return { head, middle: mid, tail, type: \'三顺子\' };\n    }\n  }\n  return null;\n}\nfunction detectThreeFlush(cards13) {\n  const comb3 = combinations(cards13, 3);\n  for (const head of comb3) {\n    if (!isFlush(head)) continue;\n    const left10 = cards13.filter(c => !head.includes(c));\n    for (const mid of combinations(left10, 5)) {\n      if (!isFlush(mid)) continue;\n      const tail = left10.filter(c => !mid.includes(c));\n      if (!isFlush(tail)) continue;\n      return { head, middle: mid, tail, type: \'三同花\' };\n    }\n  }\n  return null;\n}\nfunction detectAllSpecialSplits(cards13) {\n  return detectDragon(cards13)\n    || detectSixPairs(cards13)\n    || detectThreeStraight(cards13)\n    || detectThreeFlush(cards13)\n    || null;\n}\nfunction isStraight(cards) {\n  const vals = uniq(cards.map(cardValue)).sort((a, b) => a - b);\n  if (vals.length !== cards.length) return false;\n  for (let i = 1; i < vals.length; ++i) if (vals[i] !== vals[i - 1] + 1) return false;\n  if (vals.includes(14) && vals[0] === 2 && vals[1] === 3) {\n    const t = vals.slice(); t[t.indexOf(14)] = 1; t.sort((a, b) => a - b);\n    for (let i = 1; i < t.length; ++i) if (t[i] !== t[i - 1] + 1) return false;\n    return true;\n  }\n  return true;\n}\nfunction isFlush(cards) {\n  if (!cards.length) return false;\n  const suit = cardSuit(cards[0]);\n  return cards.every(c => cardSuit(c) === suit);\n}\n\n// ==== 牌型判定/倒水/评分 ====\nfunction handType(cards, area) {\n  if (!cards || cards.length < 3) return \"高牌\";\n  const vals = cards.map(cardValue), suits = cards.map(cardSuit),\n    uniqVals = uniq(vals), uniqSuits = uniq(suits);\n  if (cards.length === 5) {\n    if (Object.values(groupBy(vals)).some(a => a.length === 4)) return \"铁支\";\n    if (uniqSuits.length === 1 && isStraight(cards)) return \"同花顺\";\n    if (Object.values(groupBy(vals)).some(a => a.length === 3) && Object.values(groupBy(vals)).some(a => a.length === 2)) return \"葫芦\";\n    if (uniqSuits.length === 1) return \"同花\";\n    if (isStraight(cards)) return \"顺子\";\n    if (Object.values(groupBy(vals)).some(a => a.length === 3)) return \"三条\";\n    if (Object.values(groupBy(vals)).filter(a => a.length === 2).length === 2) return \"两对\";\n    if (Object.values(groupBy(vals)).some(a => a.length === 2)) return \"对子\";\n    return \"高牌\";\n  }\n  if (cards.length === 3) {\n    if (uniqVals.length === 1) return \"三条\";\n    if (Object.values(groupBy(vals)).some(a => a.length === 2)) return \"对子\";\n    return \"高牌\";\n  }\n  return \"高牌\";\n}\nfunction handTypeScore(cards, area) {\n  const t = handType(cards, area);\n  switch (t) {\n    case \"铁支\": return 8; case \"同花顺\": return 7; case \"葫芦\": return 6; case \"同花\": return 5; case \"顺子\": return 4;\n    case \"三条\": return 3; case \"两对\": return 2; case \"对子\": return 1; default: return 0;\n  }\n}\nfunction handTypeRank(cards, area) {\n  if (area === \'head\') {\n    const t = handType(cards, area);\n    if (t === \"三条\") return 4; if (t === \"对子\") return 2; return 1;\n  }\n  return handTypeScore(cards, area);\n}\nfunction isFoul(head, mid, tail) {\n  const headRank = handTypeRank(head, \'head\');\n  const midRank = handTypeRank(mid, \'middle\');\n  const tailRank = handTypeRank(tail, \'tail\');\n  if (!(headRank <= midRank && midRank <= tailRank)) return true;\n  if (headRank === midRank && compareArea(head, mid, \'head\') > 0) return true;\n  if (midRank === tailRank && compareArea(mid, tail, \'middle\') > 0) return true;\n  return false;\n}\nfunction scoreSplit(head, mid, tail) {\n  // 新增头道对子/三条奖励，优先不拆葫芦/顺子/三条\n  let sHead = evalHead(head), sMid = evalTail(mid), sTail = evalTail(tail);\n  let score = sTail * 1.9 + sMid * 1.1 + sHead * 1.0;\n  if (handType(head, \'head\') === \'三条\') score += 90;\n  if (handType(head, \'head\') === \'对子\') score += 28;\n  // 中道葫芦/顺子/同花奖励\n  if ([\'葫芦\', \'顺子\', \'同花\'].includes(handType(mid, \'middle\'))) score += 18;\n  return score;\n}\nfunction isSpecialType(head, mid, tail) {\n  const all = [...head, ...mid, ...tail], uniqVals = uniq(all.map(cardValue));\n  if (uniqVals.length === 13) return true;\n  const cnt = {}; for (const c of all) { const v = cardValue(c); cnt[v] = (cnt[v] || 0) + 1; }\n  if (Object.values(cnt).filter(x => x === 2).length === 6) return true;\n  const suit = c => cardSuit(c);\n  if ([head, mid, tail].every(arr => arr.every(x => suit(x) === suit(arr[0])))) return true;\n  if ([head, mid, tail].every(arr => isStraight(arr))) return true;\n  return false;\n}\n\n// ==== compareArea（同步sssScore.js核心） ====\nfunction compareArea(a, b, area) {\n  const typeA = handType(a, area), typeB = handType(b, area);\n  const rankA = handTypeRank(typeA, area), rankB = handTypeRank(typeB, area);\n  if (rankA !== rankB) return rankA - rankB;\n\n  const groupedA = groupBy(a.map(cardValue)), groupedB = groupBy(b.map(cardValue));\n\n  if ((typeA === \"顺子\" || typeA === \"同花顺\")) {\n    const valsA = a.map(cardValue).sort((a, b) => a - b), valsB = b.map(cardValue).sort((a, b) => a - b);\n    const maxA = valsA[valsA.length - 1], maxB = valsB[valsB.length - 1];\n    if (maxA !== maxB) return maxA - maxB;\n  }\n  if ([\"铁支\", \"三条\", \"对子\"].includes(typeA)) {\n    const mainA = parseInt(Object.keys(groupedA).find(k => groupedA[k].length === (typeA === \"铁支\" ? 4 : (typeA === \"三条\" ? 3 : 2))), 10);\n    const mainB = parseInt(Object.keys(groupedB).find(k => groupedB[k].length === (typeA === \"铁支\" ? 4 : (typeA === \"三条\" ? 3 : 2))), 10);\n    if (mainA !== mainB) return mainA - mainB;\n    const subA = a.map(cardValue).filter(v => v !== mainA).sort((x, y) => y - x);\n    const subB = b.map(cardValue).filter(v => v !== mainB).sort((x, y) => y - x);\n    for (let i = 0; i < subA.length; ++i) if (subA[i] !== subB[i]) return subA[i] - subB[i];\n    return 0;\n  }\n  if (typeA === \"葫芦\") {\n    const tripleA = parseInt(Object.keys(groupedA).find(k => groupedA[k].length === 3), 10);\n    const tripleB = parseInt(Object.keys(groupedB).find(k => groupedB[k].length === 3), 10);\n    if (tripleA !== tripleB) return tripleA - tripleB;\n    const pairA = parseInt(Object.keys(groupedA).find(k => groupedA[k].length === 2), 10);\n    const pairB = parseInt(Object.keys(groupedB).find(k => groupedB[k].length === 2), 10);\n    if (pairA !== pairB) return pairA - pairB;\n    return 0;\n  }\n  if (typeA === \"两对\") {\n    const pairsA = Object.keys(groupedA).filter(k => groupedA[k].length === 2).map(Number).sort((a, b) => b - a);\n    const pairsB = Object.keys(groupedB).filter(k => groupedB[k].length === 2).map(Number).sort((a, b) => b - a);\n    if (pairsA[0] !== pairsB[0]) return pairsA[0] - pairsB[0];\n    if (pairsA[1] !== pairsB[1]) return pairsA[1] - pairsB[1];\n    const subA = Object.keys(groupedA).find(k => groupedA[k].length === 1), subB = Object.keys(groupedB).find(k => groupedB[k].length === 1);\n    if (subA && subB && subA !== subB) return subA - subB;\n    return 0;\n  }\n  if (typeA === \"同花\") {\n    const valsA = a.map(cardValue).sort((a, b) => b - a), valsB = b.map(cardValue).sort((a, b) => b - a);\n    for (let i = 0; i < valsA.length; ++i) if (valsA[i] !== valsB[i]) return valsA[i] - valsB[i];\n    return 0;\n  }\n  const valsA = a.map(cardValue).sort((a, b) => b - a), valsB = b.map(cardValue).sort((a, b) => b - a);\n  for (let i = 0; i < valsA.length; ++i) if (valsA[i] !== valsB[i]) return valsA[i] - valsB[i];\n  return 0;\n}\n\n// ==== 头道/尾道评分 ====\nfunction evalHead(head) {\n  const t = handType(head, \'head\');\n  let score = 0;\n  if (t === \"三条\") score += 130;\n  else if (t === \"对子\") score += 36;\n  else score += 3;\n  score += getTotalValue(head) * 1.18;\n  return score;\n}\nfunction evalTail(tail) {\n  const t = handType(tail, \'tail\');\n  let score = 0;\n  if (t === \"同花顺\") score += 10000; // 强制极高分\n  if (t === \"铁支\") score += 240;\n  else if (t === \"葫芦\") score += 130;\n  else if (t === \"顺子\") score += 85;\n  else if (t === \"同花\") score += 60;\n  else if (t === \"三条\") score += 40;\n  else if (t === \"两对\") score += 22;\n  else if (t === \"对子\") score += 7;\n  else score += 1;\n  score += getTotalValue(tail) * 1.6;\n  return score;\n}\n\n// ==== 均衡分法 ====\nfunction balancedSplit(cards) {\n  const sorted = [...cards];\n  return { head: sorted.slice(0, 3), middle: sorted.slice(3, 8), tail: sorted.slice(8, 13) };\n}\n\n// ==== 核心导出：同花顺必做尾道 + 全局最优 ====\nexport function getSmartSplits(cards13, opts = {}) {\n  // 1. 特殊牌型优先\n  const special = detectAllSpecialSplits(cards13);\n  if (special) return [special];\n\n  // 2. 有同花顺，必做尾道\n  for (const tail of combinations(cards13, 5)) {\n    if (handType(tail, \'tail\') === \'同花顺\') {\n      const left8 = cards13.filter(c => !tail.includes(c));\n      let best = null, bestScore = -Infinity;\n      for (const mid of combinations(left8, 5)) {\n        const head = left8.filter(c => !mid.includes(c));\n        if (head.length !== 3) continue;\n        if (isFoul(head, mid, tail)) continue;\n        const score = scoreSplit(head, mid, tail);\n        if (score > bestScore) {\n          bestScore = score;\n          best = { head, middle: mid, tail };\n        }\n      }\n      if (best) return [best];\n      // 若所有拆法都倒水则继续全局最优法兜底\n      break;\n    }\n  }\n\n  // 3. 全局最优候选法\n  let bestSplit = null, bestScore = -Infinity;\n  const tailComb = combinations(cards13, 5)\n    .map(tail => ({ tail, score: evalTail(tail) }))\n    .sort((a, b) => b.score - a.score)\n    .slice(0, TAIL_TOP_N);\n\n  for (const { tail } of tailComb) {\n    const left8 = cards13.filter(c => !tail.includes(c));\n    const midComb = combinations(left8, 5)\n      .map(mid => ({ mid, score: evalTail(mid) }))\n      .sort((a, b) => b.score - a.score)\n      .slice(0, MID_TOP_N);\n\n    for (const { mid } of midComb) {\n      const head = left8.filter(c => !mid.includes(c));\n      if (head.length !== 3) continue;\n      if (isFoul(head, mid, tail)) continue;\n      const score = scoreSplit(head, mid, tail);\n      let tieBreaker = 0;\n      if (handType(head, \'head\') === \'三条\') tieBreaker += 1000;\n      if (handType(head, \'head\') === \'对子\') tieBreaker += 300;\n      if ([\'葫芦\', \'顺子\', \'同花\'].includes(handType(mid, \'middle\'))) tieBreaker += 40;\n      if (score + tieBreaker > bestScore) {\n        bestScore = score + tieBreaker;\n        bestSplit = { head, middle: mid, tail };\n      }\n    }\n  }\n  if (bestSplit) return [bestSplit];\n  // 4. 兜底均匀分配\n  return [balancedSplit(cards13)];\n}\n\nexport function aiSmartSplit(cards13, opts) {\n  const splits = getSmartSplits(cards13, opts);\n  return splits[0] || balancedSplit(cards13);\n}\nexport function getPlayerSmartSplits(cards13, opts) {\n  return getSmartSplits(cards13, opts);\n}\nexport function fillAiPlayers(playersArr) {\n  return playersArr.map(p =>\n    p.isAI && Array.isArray(p.cards13) && p.cards13.length === 13\n      ? { ...p, ...aiSmartSplit(p.cards13) }\n      : p\n  );\n}\n\nexport { isFoul };\n